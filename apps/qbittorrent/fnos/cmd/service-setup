### Generic variables and functions
### -------------------------------


PACKAGE_BASE="${TRIM_APPDEST}"
SVC_CWD="${PACKAGE_BASE}"

QBIT_BIN="qbittorrent-nox"
QBIT_CONF="${TRIM_PKGVAR}/qBittorrent/config/qBittorrent.conf"
PORT=""
if [ -f "${QBIT_CONF}" ]; then
    PORT=`get_key_value "${QBIT_CONF}" "WebUI\Port"`
fi
UIPORT=""
if [ -f "${PACKAGE_BASE}/ui/config" ]; then
    UIPORT=`cat "${PACKAGE_BASE}/ui/config" | jq -r '.".url"."'${TRIM_APPNAME}'.Application"."port"'`
fi

if [ -z "${PORT}" ] || [ "${PORT}" = "null" ]; then
    PORT="${UIPORT}"
fi
if [ -z "${PORT}" ] || [ "${PORT}" = "null" ]; then
    PORT="8085"
fi

### Package specific variables and functions
### ----------------------------------------

MEM=`free -m | grep Mem: | awk {'print $2'}`
ulimit -m `expr $MEM / 3 \* 1024`

SERVICE_COMMAND[0]="bin/${QBIT_BIN} --profile=${TRIM_PKGVAR} --webui-port=${PORT}"

# Rename framework log to avoid confusion with qbittorrent.log
LOG_FILE="${TRIM_PKGVAR}/service.log"

SVC_BACKGROUND=y
SVC_WRITE_PID=y

### Helper functions
### ----------------------------------------

# 确保 qbittorrent-nox 进程完全终止
# stop_daemon 依赖 PID 文件，若 PID 文件丢失或过期则无法杀死进程
# 此函数按进程名兜底，确保不留残留
ensure_qbit_stopped() {
    pkill -f "${QBIT_BIN}" 2>/dev/null || true
    sleep 2
    # 仍未退出则强制杀
    if pgrep -f "${QBIT_BIN}" > /dev/null 2>&1; then
        pkill -9 -f "${QBIT_BIN}" 2>/dev/null || true
        sleep 1
    fi
}

# 等待端口释放，避免新进程启动时端口占用
wait_for_port_release() {
    local port="$1"
    local max_wait="${2:-15}"
    local i=0
    while [ $i -lt $max_wait ]; do
        if ! ss -tln sport = ":${port}" 2>/dev/null | grep -q LISTEN; then
            return 0
        fi
        sleep 1
        i=$((i + 1))
    done
    return 1
}

### Lifecycle hooks
### ----------------------------------------

service_preupgrade() {
    # 升级前确保旧进程完全退出，防止新进程启动时端口占用
    ensure_qbit_stopped
    wait_for_port_release "${PORT}" 10 || true
}

service_prestart() {
    # 启动前检查端口，处理残留进程或端口冲突
    if ss -tln sport = ":${PORT}" 2>/dev/null | grep -q LISTEN; then
        # 是 qbittorrent 自身的残留进程 → 尝试清理
        if pgrep -f "${QBIT_BIN}" > /dev/null 2>&1; then
            echo "发现残留的 qBittorrent 进程，正在清理..." >> ${LOG_FILE}
            ensure_qbit_stopped
            if ! wait_for_port_release "${PORT}" 10; then
                error_exit "端口 ${PORT} 被 qBittorrent 残留进程占用，清理失败"
            fi
        else
            error_exit "端口 ${PORT} 已被其他程序占用，无法启动 qBittorrent。请检查端口冲突或修改 WebUI 端口。"
        fi
    fi
}

service_preuninst() {
    ensure_qbit_stopped
}

service_poststop() {
    ensure_qbit_stopped
}

service_postupgrade() {
    log_step "qbittorrent_postupgrade"

    # Symlink persistent config directory
    if [ -d "${TRIM_PKGVAR}/config" ]; then
        $RM "${TRIM_APPDEST}/conf" 2>&1 | install_log
        $LN "${TRIM_PKGVAR}/config" "${TRIM_APPDEST}/conf" 2>&1 | install_log
    fi

    # Add default credentials if missing (upgrade from older versions)
    local need_password_warning=false

    if [ -f "${QBIT_CONF}" ]; then
        if ! grep -q "WebUI\\\\Username" "${QBIT_CONF}"; then
            sed -i '/WebUI\\Port/i\WebUI\\Username=admin' ${QBIT_CONF}
            need_password_warning=true
        fi

        if ! grep -q "Password_PBKDF2" "${QBIT_CONF}"; then
            sed -i '/WebUI\\Port/i\WebUI\\Password_PBKDF2=\"@ByteArray(xK2EwRvfGtxfF+Ot9v4WYQ==:bNStY\/6mFYYW8m\/Xm4xSbBjoR2tZNsLZ4KvdUzyCLEOg7tfpchVJucIK9Dwcp6Xe9DI4RwpoCPI9zhicTdtf5A==)\"' ${QBIT_CONF}
            need_password_warning=true
        fi
    fi

    if [ "$need_password_warning" = true ]; then
        echo "默认用户名: admin，密码: adminadmin<br/>"
        echo "请及时修改默认密码！Change default password NOW！！！"
    fi
}
